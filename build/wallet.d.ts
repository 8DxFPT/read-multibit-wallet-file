// generated by Proto2Typescript. do not touch!

declare module MultibitWallet {
	interface ProtoBufModel {
		toArrayBuffer(): ArrayBuffer;
		//toBuffer(): NodeBuffer;
		//encode(): ByteBuffer;
		toBase64(): string;
		toString(): string;
	}

	export interface ProtoBufBuilder {
		PeerAddress: PeerAddressBuilder;
		EncryptedData: EncryptedDataBuilder;
		DeterministicKey: DeterministicKeyBuilder;
		Key: KeyBuilder;
		Script: ScriptBuilder;
		TransactionInput: TransactionInputBuilder;
		TransactionOutput: TransactionOutputBuilder;
		TransactionConfidence: TransactionConfidenceBuilder;
		Transaction: TransactionBuilder;
		ScryptParameters: ScryptParametersBuilder;
		Extension: ExtensionBuilder;
		Tag: TagBuilder;
		TransactionSigner: TransactionSignerBuilder;
		Wallet: WalletBuilder;
		ExchangeRate: ExchangeRateBuilder;
		
	}
}

declare module MultibitWallet {

	export interface PeerAddress extends ProtoBufModel {
		ip_address: ByteBuffer;
		getIpAddress() : ByteBuffer;
		setIpAddress(ipAddress : ByteBuffer): void;
		port: number;
		getPort() : number;
		setPort(port : number): void;
		services: number;
		getServices() : number;
		setServices(services : number): void;
		
	}
	
	export interface PeerAddressBuilder {
		new(): PeerAddress;
		decode(buffer: ArrayBuffer) : PeerAddress;
		//decode(buffer: NodeBuffer) : PeerAddress;
		//decode(buffer: ByteArrayBuffer) : PeerAddress;
		decode64(buffer: string) : PeerAddress;
		
	}	
}

declare module MultibitWallet {

	export interface EncryptedData extends ProtoBufModel {
		initialisation_vector: ByteBuffer;
		getInitialisationVector() : ByteBuffer;
		setInitialisationVector(initialisationVector : ByteBuffer): void;
		encrypted_private_key: ByteBuffer;
		getEncryptedPrivateKey() : ByteBuffer;
		setEncryptedPrivateKey(encryptedPrivateKey : ByteBuffer): void;
		
	}
	
	export interface EncryptedDataBuilder {
		new(): EncryptedData;
		decode(buffer: ArrayBuffer) : EncryptedData;
		//decode(buffer: NodeBuffer) : EncryptedData;
		//decode(buffer: ByteArrayBuffer) : EncryptedData;
		decode64(buffer: string) : EncryptedData;
		
	}	
}

declare module MultibitWallet {

	export interface DeterministicKey extends ProtoBufModel {
		chain_code: ByteBuffer;
		getChainCode() : ByteBuffer;
		setChainCode(chainCode : ByteBuffer): void;
		path: number[];
		getPath() : number[];
		setPath(path : number[]): void;
		issued_subkeys?: number;
		getIssuedSubkeys() : number;
		setIssuedSubkeys(issuedSubkeys : number): void;
		lookahead_size?: number;
		getLookaheadSize() : number;
		setLookaheadSize(lookaheadSize : number): void;
		isFollowing?: boolean;
		getIsFollowing() : boolean;
		setIsFollowing(isFollowing : boolean): void;
		sigsRequiredToSpend?: number;
		getSigsRequiredToSpend() : number;
		setSigsRequiredToSpend(sigsRequiredToSpend : number): void;
		
	}
	
	export interface DeterministicKeyBuilder {
		new(): DeterministicKey;
		decode(buffer: ArrayBuffer) : DeterministicKey;
		//decode(buffer: NodeBuffer) : DeterministicKey;
		//decode(buffer: ByteArrayBuffer) : DeterministicKey;
		decode64(buffer: string) : DeterministicKey;
		
	}	
}

declare module MultibitWallet {

	export interface Key extends ProtoBufModel {
		type: Key.Type;
		getType() : Key.Type;
		setType(type : Key.Type): void;
		secret_bytes?: ByteBuffer;
		getSecretBytes() : ByteBuffer;
		setSecretBytes(secretBytes : ByteBuffer): void;
		encrypted_data?: EncryptedData;
		getEncryptedData() : EncryptedData;
		setEncryptedData(encryptedData : EncryptedData): void;
		public_key?: ByteBuffer;
		getPublicKey() : ByteBuffer;
		setPublicKey(publicKey : ByteBuffer): void;
		label?: string;
		getLabel() : string;
		setLabel(label : string): void;
		creation_timestamp?: number;
		getCreationTimestamp() : number;
		setCreationTimestamp(creationTimestamp : number): void;
		deterministic_key?: DeterministicKey;
		getDeterministicKey() : DeterministicKey;
		setDeterministicKey(deterministicKey : DeterministicKey): void;
		deterministic_seed?: ByteBuffer;
		getDeterministicSeed() : ByteBuffer;
		setDeterministicSeed(deterministicSeed : ByteBuffer): void;
		encrypted_deterministic_seed?: EncryptedData;
		getEncryptedDeterministicSeed() : EncryptedData;
		setEncryptedDeterministicSeed(encryptedDeterministicSeed : EncryptedData): void;
		
	}
	
	export interface KeyBuilder {
		new(): Key;
		decode(buffer: ArrayBuffer) : Key;
		//decode(buffer: NodeBuffer) : Key;
		//decode(buffer: ByteArrayBuffer) : Key;
		decode64(buffer: string) : Key;
		Type: Key.Type;
		
	}	
}

declare module MultibitWallet.Key {
	export const enum Type {
		ORIGINAL = 1,
		ENCRYPTED_SCRYPT_AES = 2,
		DETERMINISTIC_MNEMONIC = 3,
		DETERMINISTIC_KEY = 4,
		
	}
}

declare module MultibitWallet {

	export interface Script extends ProtoBufModel {
		program: ByteBuffer;
		getProgram() : ByteBuffer;
		setProgram(program : ByteBuffer): void;
		creation_timestamp: number;
		getCreationTimestamp() : number;
		setCreationTimestamp(creationTimestamp : number): void;
		
	}
	
	export interface ScriptBuilder {
		new(): Script;
		decode(buffer: ArrayBuffer) : Script;
		//decode(buffer: NodeBuffer) : Script;
		//decode(buffer: ByteArrayBuffer) : Script;
		decode64(buffer: string) : Script;
		
	}	
}

declare module MultibitWallet {

	export interface TransactionInput extends ProtoBufModel {
		transaction_out_point_hash: ByteBuffer;
		getTransactionOutPointHash() : ByteBuffer;
		setTransactionOutPointHash(transactionOutPointHash : ByteBuffer): void;
		transaction_out_point_index: number;
		getTransactionOutPointIndex() : number;
		setTransactionOutPointIndex(transactionOutPointIndex : number): void;
		script_bytes: ByteBuffer;
		getScriptBytes() : ByteBuffer;
		setScriptBytes(scriptBytes : ByteBuffer): void;
		sequence?: number;
		getSequence() : number;
		setSequence(sequence : number): void;
		value?: number;
		getValue() : number;
		setValue(value : number): void;
		
	}
	
	export interface TransactionInputBuilder {
		new(): TransactionInput;
		decode(buffer: ArrayBuffer) : TransactionInput;
		//decode(buffer: NodeBuffer) : TransactionInput;
		//decode(buffer: ByteArrayBuffer) : TransactionInput;
		decode64(buffer: string) : TransactionInput;
		
	}	
}

declare module MultibitWallet {

	export interface TransactionOutput extends ProtoBufModel {
		value: number;
		getValue() : number;
		setValue(value : number): void;
		script_bytes: ByteBuffer;
		getScriptBytes() : ByteBuffer;
		setScriptBytes(scriptBytes : ByteBuffer): void;
		spent_by_transaction_hash?: ByteBuffer;
		getSpentByTransactionHash() : ByteBuffer;
		setSpentByTransactionHash(spentByTransactionHash : ByteBuffer): void;
		spent_by_transaction_index?: number;
		getSpentByTransactionIndex() : number;
		setSpentByTransactionIndex(spentByTransactionIndex : number): void;
		
	}
	
	export interface TransactionOutputBuilder {
		new(): TransactionOutput;
		decode(buffer: ArrayBuffer) : TransactionOutput;
		//decode(buffer: NodeBuffer) : TransactionOutput;
		//decode(buffer: ByteArrayBuffer) : TransactionOutput;
		decode64(buffer: string) : TransactionOutput;
		
	}	
}

declare module MultibitWallet {

	export interface TransactionConfidence extends ProtoBufModel {
		type?: TransactionConfidence.Type;
		getType() : TransactionConfidence.Type;
		setType(type : TransactionConfidence.Type): void;
		appeared_at_height?: number;
		getAppearedAtHeight() : number;
		setAppearedAtHeight(appearedAtHeight : number): void;
		overriding_transaction?: ByteBuffer;
		getOverridingTransaction() : ByteBuffer;
		setOverridingTransaction(overridingTransaction : ByteBuffer): void;
		depth?: number;
		getDepth() : number;
		setDepth(depth : number): void;
		broadcast_by: PeerAddress[];
		getBroadcastBy() : PeerAddress[];
		setBroadcastBy(broadcastBy : PeerAddress[]): void;
		source?: TransactionConfidence.Source;
		getSource() : TransactionConfidence.Source;
		setSource(source : TransactionConfidence.Source): void;
		
	}
	
	export interface TransactionConfidenceBuilder {
		new(): TransactionConfidence;
		decode(buffer: ArrayBuffer) : TransactionConfidence;
		//decode(buffer: NodeBuffer) : TransactionConfidence;
		//decode(buffer: ByteArrayBuffer) : TransactionConfidence;
		decode64(buffer: string) : TransactionConfidence;
		Type: TransactionConfidence.Type;
		Source: TransactionConfidence.Source;
		
	}	
}

declare module MultibitWallet.TransactionConfidence {
	export const enum Type {
		UNKNOWN = 0,
		BUILDING = 1,
		PENDING = 2,
		NOT_IN_BEST_CHAIN = 3,
		DEAD = 4,
		
	}
}

declare module MultibitWallet.TransactionConfidence {
	export const enum Source {
		SOURCE_UNKNOWN = 0,
		SOURCE_NETWORK = 1,
		SOURCE_SELF = 2,
		
	}
}

declare module MultibitWallet {

	export interface Transaction extends ProtoBufModel {
		version: number;
		getVersion() : number;
		setVersion(version : number): void;
		hash: ByteBuffer;
		getHash() : ByteBuffer;
		setHash(hash : ByteBuffer): void;
		pool?: Transaction.Pool;
		getPool() : Transaction.Pool;
		setPool(pool : Transaction.Pool): void;
		lock_time?: number;
		getLockTime() : number;
		setLockTime(lockTime : number): void;
		updated_at?: number;
		getUpdatedAt() : number;
		setUpdatedAt(updatedAt : number): void;
		transaction_input: TransactionInput[];
		getTransactionInput() : TransactionInput[];
		setTransactionInput(transactionInput : TransactionInput[]): void;
		transaction_output: TransactionOutput[];
		getTransactionOutput() : TransactionOutput[];
		setTransactionOutput(transactionOutput : TransactionOutput[]): void;
		block_hash: ByteBuffer[];
		getBlockHash() : ByteBuffer[];
		setBlockHash(blockHash : ByteBuffer[]): void;
		block_relativity_offsets: number[];
		getBlockRelativityOffsets() : number[];
		setBlockRelativityOffsets(blockRelativityOffsets : number[]): void;
		confidence?: TransactionConfidence;
		getConfidence() : TransactionConfidence;
		setConfidence(confidence : TransactionConfidence): void;
		purpose?: Transaction.Purpose;
		getPurpose() : Transaction.Purpose;
		setPurpose(purpose : Transaction.Purpose): void;
		exchange_rate?: ExchangeRate;
		getExchangeRate() : ExchangeRate;
		setExchangeRate(exchangeRate : ExchangeRate): void;
		memo?: string;
		getMemo() : string;
		setMemo(memo : string): void;
		
	}
	
	export interface TransactionBuilder {
		new(): Transaction;
		decode(buffer: ArrayBuffer) : Transaction;
		//decode(buffer: NodeBuffer) : Transaction;
		//decode(buffer: ByteArrayBuffer) : Transaction;
		decode64(buffer: string) : Transaction;
		Pool: Transaction.Pool;
		Purpose: Transaction.Purpose;
		
	}	
}

declare module MultibitWallet.Transaction {
	export const enum Pool {
		UNSPENT = 4,
		SPENT = 5,
		INACTIVE = 2,
		DEAD = 10,
		PENDING = 16,
		PENDING_INACTIVE = 18,
		
	}
}

declare module MultibitWallet.Transaction {
	export const enum Purpose {
		UNKNOWN = 0,
		USER_PAYMENT = 1,
		KEY_ROTATION = 2,
		ASSURANCE_CONTRACT_CLAIM = 3,
		ASSURANCE_CONTRACT_PLEDGE = 4,
		ASSURANCE_CONTRACT_STUB = 5,
		
	}
}

declare module MultibitWallet {

	export interface ScryptParameters extends ProtoBufModel {
		salt: ByteBuffer;
		getSalt() : ByteBuffer;
		setSalt(salt : ByteBuffer): void;
		n?: number;
		getN() : number;
		setN(n : number): void;
		r?: number;
		getR() : number;
		setR(r : number): void;
		p?: number;
		getP() : number;
		setP(p : number): void;
		
	}
	
	export interface ScryptParametersBuilder {
		new(): ScryptParameters;
		decode(buffer: ArrayBuffer) : ScryptParameters;
		//decode(buffer: NodeBuffer) : ScryptParameters;
		//decode(buffer: ByteArrayBuffer) : ScryptParameters;
		decode64(buffer: string) : ScryptParameters;
		
	}	
}

declare module MultibitWallet {

	export interface Extension extends ProtoBufModel {
		id: string;
		getId() : string;
		setId(id : string): void;
		data: ByteBuffer;
		getData() : ByteBuffer;
		setData(data : ByteBuffer): void;
		mandatory: boolean;
		getMandatory() : boolean;
		setMandatory(mandatory : boolean): void;
		
	}
	
	export interface ExtensionBuilder {
		new(): Extension;
		decode(buffer: ArrayBuffer) : Extension;
		//decode(buffer: NodeBuffer) : Extension;
		//decode(buffer: ByteArrayBuffer) : Extension;
		decode64(buffer: string) : Extension;
		
	}	
}

declare module MultibitWallet {

	export interface Tag extends ProtoBufModel {
		tag: string;
		getTag() : string;
		setTag(tag : string): void;
		data: ByteBuffer;
		getData() : ByteBuffer;
		setData(data : ByteBuffer): void;
		
	}
	
	export interface TagBuilder {
		new(): Tag;
		decode(buffer: ArrayBuffer) : Tag;
		//decode(buffer: NodeBuffer) : Tag;
		//decode(buffer: ByteArrayBuffer) : Tag;
		decode64(buffer: string) : Tag;
		
	}	
}

declare module MultibitWallet {

	export interface TransactionSigner extends ProtoBufModel {
		class_name: string;
		getClassName() : string;
		setClassName(className : string): void;
		data?: ByteBuffer;
		getData() : ByteBuffer;
		setData(data : ByteBuffer): void;
		
	}
	
	export interface TransactionSignerBuilder {
		new(): TransactionSigner;
		decode(buffer: ArrayBuffer) : TransactionSigner;
		//decode(buffer: NodeBuffer) : TransactionSigner;
		//decode(buffer: ByteArrayBuffer) : TransactionSigner;
		decode64(buffer: string) : TransactionSigner;
		
	}	
}

declare module MultibitWallet {

	export interface Wallet extends ProtoBufModel {
		network_identifier: string;
		getNetworkIdentifier() : string;
		setNetworkIdentifier(networkIdentifier : string): void;
		last_seen_block_hash?: ByteBuffer;
		getLastSeenBlockHash() : ByteBuffer;
		setLastSeenBlockHash(lastSeenBlockHash : ByteBuffer): void;
		last_seen_block_height?: number;
		getLastSeenBlockHeight() : number;
		setLastSeenBlockHeight(lastSeenBlockHeight : number): void;
		last_seen_block_time_secs?: number;
		getLastSeenBlockTimeSecs() : number;
		setLastSeenBlockTimeSecs(lastSeenBlockTimeSecs : number): void;
		key: Key[];
		getKey() : Key[];
		setKey(key : Key[]): void;
		transaction: Transaction[];
		getTransaction() : Transaction[];
		setTransaction(transaction : Transaction[]): void;
		watched_script: Script[];
		getWatchedScript() : Script[];
		setWatchedScript(watchedScript : Script[]): void;
		encryption_type?: Wallet.EncryptionType;
		getEncryptionType() : Wallet.EncryptionType;
		setEncryptionType(encryptionType : Wallet.EncryptionType): void;
		encryption_parameters?: ScryptParameters;
		getEncryptionParameters() : ScryptParameters;
		setEncryptionParameters(encryptionParameters : ScryptParameters): void;
		version?: number;
		getVersion() : number;
		setVersion(version : number): void;
		extension: Extension[];
		getExtension() : Extension[];
		setExtension(extension : Extension[]): void;
		description?: string;
		getDescription() : string;
		setDescription(description : string): void;
		key_rotation_time?: number;
		getKeyRotationTime() : number;
		setKeyRotationTime(keyRotationTime : number): void;
		tags: Tag[];
		getTags() : Tag[];
		setTags(tags : Tag[]): void;
		transaction_signers: TransactionSigner[];
		getTransactionSigners() : TransactionSigner[];
		setTransactionSigners(transactionSigners : TransactionSigner[]): void;
		
	}
	
	export interface WalletBuilder {
		new(): Wallet;
		decode(buffer: ArrayBuffer) : Wallet;
		//decode(buffer: NodeBuffer) : Wallet;
		//decode(buffer: ByteArrayBuffer) : Wallet;
		decode64(buffer: string) : Wallet;
		EncryptionType: Wallet.EncryptionType;
		
	}	
}

declare module MultibitWallet.Wallet {
	export const enum EncryptionType {
		UNENCRYPTED = 1,
		ENCRYPTED_SCRYPT_AES = 2,
		
	}
}

declare module MultibitWallet {

	export interface ExchangeRate extends ProtoBufModel {
		coin_value: number;
		getCoinValue() : number;
		setCoinValue(coinValue : number): void;
		fiat_value: number;
		getFiatValue() : number;
		setFiatValue(fiatValue : number): void;
		fiat_currency_code: string;
		getFiatCurrencyCode() : string;
		setFiatCurrencyCode(fiatCurrencyCode : string): void;
		
	}
	
	export interface ExchangeRateBuilder {
		new(): ExchangeRate;
		decode(buffer: ArrayBuffer) : ExchangeRate;
		//decode(buffer: NodeBuffer) : ExchangeRate;
		//decode(buffer: ByteArrayBuffer) : ExchangeRate;
		decode64(buffer: string) : ExchangeRate;
		
	}	
}
